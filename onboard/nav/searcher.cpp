#include "searcher.hpp"
#include "utilities.hpp"
#include "stateMachine.hpp"

#include <iostream>
#include <time.h>
#include <cmath>

/*****************************************************/
/* Funtions for StateMachine to access Search points */
/*****************************************************/
Odometry Searcher::frontSearchPoint( )
{
    return mSearchPoints.front();
}

void Searcher::popSearchPoint( )
{
    mSearchPoints.pop_front();
    return;
}

// add intermediate points between the existing search points in a path generated by a search algorithm.
// The maximum separation between any points in the search point list is determined by the rover's sight distance.
void Searcher::insertIntermediatePoints( Rover * phoebe, const rapidjson::Document& roverConfig )
{
    double visionDistance = roverConfig[ "computerVision" ][ "visionDistance" ].GetDouble();
    const double maxDifference = 2 * visionDistance;

    for( int i = 0; i < int( mSearchPoints.size() ) - 1; ++i )
    {
        Odometry point1 = mSearchPoints.at( i );
        Odometry point2 = mSearchPoints.at( i + 1 );
        double distance = estimateNoneuclid( point1, point2 );
        if ( distance > maxDifference )
        {
            int numPoints = int( ceil( distance / maxDifference ) - 1 );
            double newDifference = distance / ( numPoints + 1 );
            double bearing = calcBearing( point1, point2 );
            for ( int j = 0; j < numPoints; ++j )
            {
                Odometry startPoint = mSearchPoints.at( i );
                Odometry newOdom = createOdom( startPoint, bearing, newDifference, phoebe );
                auto insertPosition = mSearchPoints.begin() + i + 1;
                mSearchPoints.insert( insertPosition, newOdom );
                ++i;
            }
        }
    }
}

/*****************************************************/
/* Searcher Run Fuction */
/*****************************************************/
NavState Searcher::run( Rover * phoebe, const rapidjson::Document& roverConfig )
{
    switch ( phoebe->roverStatus().currentState() )
    {
        case NavState::SearchSpin:
        {
            return executeSearchSpin( phoebe, roverConfig );
        }

        case NavState::SearchSpinWait:
        {
            return executeSearchSpinWait( phoebe, roverConfig );
        }

        case NavState::SearchTurn:
        {
            return executeSearchTurn( phoebe, roverConfig );
        }

        case NavState::SearchDrive:
        {
            return executeSearchDrive( phoebe );
        }

        case NavState::TurnToBall:
        {
            return executeTurnToBall( phoebe );
        }

        case NavState::DriveToBall:
        {
            return executeDriveToBall( phoebe );
        }

        default:
        {
            return NavState::Unknown;
        }
    } // switch
} // run()

/*****************************************************/
/* Helpers */
/*****************************************************/


// Executes the logic for a search spin. If at a multiple of
// waitStepSize, the rover will go to SearchSpinWait. If the rover
// detects the ball, it proceeds to the ball. If finished with a 360,
// the rover moves on to the next phase of the search. Else continues
// to search spin.
NavState Searcher::executeSearchSpin( Rover* phoebe, const rapidjson::Document& roverConfig )
{
    // degrees to turn to before performing a search wait.
    double waitStepSize = roverConfig[ "computerVision" ][ "searchWaitStepSize" ].GetDouble();
    static double nextStop = 0; // to force the rover to wait initially
    static double mOriginalSpinAngle = 0; //initialize, is corrected on first call

    if( phoebe->roverStatus().tennisBall().found )
    {
        mSearchPoints.push_front( phoebe->roverStatus().odometry() );
        return NavState::TurnToBall;
    }
    if ( nextStop == 0 )
    {
        //get current angle and set as origAngle
        mOriginalSpinAngle = phoebe->roverStatus().odometry().bearing_deg; //doublecheck
        nextStop = mOriginalSpinAngle;
    }
    if( phoebe->turn( nextStop ) )
    {
        if( nextStop - mOriginalSpinAngle >= 360 )
        {
            nextStop = 0;
            return NavState::SearchTurn;
        }
        nextStop += waitStepSize;
        return NavState::SearchSpinWait;
    }
    return NavState::SearchSpin;
} // executeSearchSpin()


// Executes the logic for waiting during a search spin so that CV can
// look for the tennis ball. If the rover detects the ball, it proceeds
// to the ball. If the rover is done waiting, it continues the search
// spin. Else the rover keeps waiting.
NavState Searcher::executeSearchSpinWait( Rover* phoebe, const rapidjson::Document& roverConfig )
{
    static bool started = false;
    static time_t startTime;
    if( phoebe->roverStatus().tennisBall().found )
    {
        mSearchPoints.push_front( phoebe->roverStatus().odometry() );
        return NavState::TurnToBall;
    }
    if( !started )
    {
        startTime = time( nullptr );
        started = true;
    }
    double waitTime = roverConfig[ "computerVision" ][ "searchWaitTime" ].GetDouble();
    if( difftime( time( nullptr ), startTime ) > waitTime )
    {
        started = false;
        return NavState::SearchSpin;
    }
    else
    {
        return NavState::SearchSpinWait;
    }
}

// Executes the logic for turning while searching.
// If no remaining search points, it proceeds to change search algorithms.
// If the rover detects the tennis ball, it proceeds to the ball.
// If the rover finishes turning, it proceeds to driving while searching.
// Else the rover keeps turning to the next Waypoint.
NavState Searcher::executeSearchTurn( Rover* phoebe, const rapidjson::Document& roverConfig )
{
    if( mSearchPoints.empty() )
    {
        return NavState::ChangeSearchAlg;
    }
    if( phoebe->roverStatus().tennisBall().found )
    {
        mSearchPoints.push_front( phoebe->roverStatus().odometry() );
        return NavState::TurnToBall;
    }
    Odometry& nextSearchPoint = mSearchPoints.front();
    if( phoebe->turn( nextSearchPoint ) )
    {
        return NavState::SearchDrive;
    }
    return NavState::SearchTurn;
} // executeSearchTurn()

// Executes the logic for driving while searching.
// If the rover detects the tennis ball, it proceeds to the ball.
// If the rover detects an obstacle, it proceeds to obstacle avoidance.
// If the rover finishes driving, it proceeds to turning to the next Waypoint.
// If the rover is still on course, it keeps driving to the next Waypoint.
// Else the rover turns to the next Waypoint or turns back to the current Waypoint
NavState Searcher::executeSearchDrive( Rover * phoebe )
{
    if( phoebe->roverStatus().tennisBall().found )
    {
        mSearchPoints.push_front( phoebe->roverStatus().odometry() );
        return NavState::TurnToBall;
    }
    if( phoebe->roverStatus().obstacle().detected )
    {
        stateMachine->updateObstacleAngle( phoebe->roverStatus().obstacle().bearing );
        return NavState::SearchTurnAroundObs;
    }
    const Odometry& nextSearchPoint = mSearchPoints.front();
    DriveStatus driveStatus = phoebe->drive( nextSearchPoint );

    if( driveStatus == DriveStatus::Arrived )
    {
        mSearchPoints.pop_front();
        return NavState::SearchSpin;
    }
    if( driveStatus == DriveStatus::OnCourse )
    {
        return NavState::SearchDrive;
    }
    return NavState::SearchTurn;
} // executeSearchDrive()

// Executes the logic for turning to the tennis ball.
// If the rover loses the ball, it starts to search again.
// If the rover finishes turning to the ball, it drives to the ball.
// Else the rover continues to turn to to the ball.
NavState Searcher::executeTurnToBall( Rover * phoebe )
{
    if( !phoebe->roverStatus().tennisBall().found )
    {
        cerr << "Lost the tennis ball\n";
        return NavState::SearchSpin;
    }
    if( phoebe->turn( phoebe->roverStatus().tennisBall().bearing +
                       phoebe->roverStatus().odometry().bearing_deg ) )
    {
        return NavState::DriveToBall;
    }
    return NavState::TurnToBall;
} // executeTurnToBall()

// Executes the logic for driving to the tennis ball.
// If the rover loses the ball, it starts the search again.
// If the rover detects an obstacle, it proceeds to go around the obstacle.
// If the rover finishes driving to the ball, it moves on to the next Waypoint.
// If the rover is on course, it keeps driving to the ball.
// Else, it turns back to face the ball.
NavState Searcher::executeDriveToBall( Rover * phoebe )
{
    if( !phoebe->roverStatus().tennisBall().found )
    {
        cerr << "Lost the tennis ball\n";
        return NavState::SearchSpin;
    }
    if( phoebe->roverStatus().obstacle().detected )
    {
        stateMachine->updateObstacleAngle( phoebe->roverStatus().obstacle().bearing );
        return NavState::SearchTurnAroundObs;
    }

    DriveStatus driveStatus = phoebe->drive( phoebe->roverStatus().tennisBall().distance,
                                             phoebe->roverStatus().tennisBall().bearing +
                                             phoebe->roverStatus().odometry().bearing_deg,
                                             true );
    if( driveStatus == DriveStatus::Arrived )
    {
        phoebe->roverStatus().path().pop();
        stateMachine->updateCompletedPoints();
        stateMachine->updateFoundBalls();
        return NavState::Turn;
    }
    if( driveStatus == DriveStatus::OnCourse )
    {
        return NavState::DriveToBall;
    }
    return NavState::TurnToBall;
} // executeDriveToBall()

/*************************************************************************/
/* TODOS */
/*************************************************************************/
// TODO: save location of ball then go around object? ( Execute drive to ball )
